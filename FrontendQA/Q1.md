1. setState是同步还是异步  
setState本身不是异步的，但是如果setState的时候react正处于更新状态，当前更新会被暂存，等上一次更新执行后执行，这个过程给人一种异步的假象。  

2. 什么是react高阶组件  
一个接受组件，返回一个新组件的纯函数。目的是为了在多个组件之间复用逻辑。（自定义hook）

3. 原型链  
```js
function Person(name = 'zzq') {
  this.name = name
}
const zzq = new Person()
zzq.__proto__ === Person.prototype // 指向实例原型
zzq.__proto__.constructor === Person // 实例原型的 constructor 指向原型的构造函数
zzq.__protp__.__proto__ === Object.prototype // 实例原型 继承自 Object的实例原型
```  
实例原型之间的继承链条就叫原型链  

对new理解：new 申请内存, 创建对象,当调用new时，后台会隐式执行new Object()创建对象。所以，通过new创建的字符串、数字是引用类型，而是非值类型。 

4. instanceof 原理
判断右边变量的 prototype(原型实例) 是否在左边变量的原型链上
```js
null instanceof null // TypeError: Right-hand side of 'instanceof' is not an object
typeof null === 'object'
```

5. bind、call、apply  
```js
function Sup() {
  this.name = 'sup'
  this.fn = function(arg1, arg2) {
    console.log(this.name, arg1, arg2)
  }
}

function Sub() {
  this.name = 'sub'
}

const sup = new Sup()
const sub = new Sub()

sup.fn('1', '2')

const fnBind = sup.fn.bind(sub, '1', '2')
fnBind()

sup.fn.call(sub, '1', '2')

sup.fn.apply(sub, ['1', '2'])

```  
call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。  
bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。

6. position  
static: 默认定位，文档布局流中的正常位置  
relative： 相对定位，正常文档流中，相对static的定位  
absolute： 绝对定位，不再存在于正常文档布局流中，有自己的层，相对于他的“包含元素”的定位
如果所有的父元素都是static，那就是相对于“初始块容器”（初始块容器有着和浏览器视口一样的尺寸， 
\<html>元素也被包含在这个容器中）的定位。  
fixed： 固定定位，与绝对定位的工作方式完全相同，只有一个主要区别：固定定位固定元素则是相对于浏览器视口本身

7. 重排(回流)和重绘  
flow: 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点 
paint: 将布局绘制(paint)在屏幕上，显示出整个页面。
reflow，页面布局发生改变，
repaint，重新绘制图像  
但重排一定会导致重绘。 

8. https
在http的基础上，服务器将自己的网站信息（域名等）和加密公钥交给第三方机构，第三方机构用自己的私钥加密，生成证书颁发给服务器。客户端获取证书后使用第三方机构的公钥解密，获取到服务器的公钥来加密通信。

9. react合成事件  
通过在jsx方式绑定的事件  
特点：React上注册的事件最终会绑在document节点上、React自身实现了一套冒泡机制，合成事件中调用e.stopProgration只会阻止合成事件不会阻止原生事件执行、React通过冒泡的方式从触发的组件到父组件回溯

10. 为什么有的时候两次setState只执行一次  
直接传递对象的setState会被合并成一次，使用函数传递state不会被合并

11. Redux原则
单一数据源（状态更好管理、撤销重做等操作更易实现）  
state只读，单向数据流，数据更好跟踪  
纯函数修改，没有副作用，相同的输入永远是相同的输出，更容易调试及单元测试

12. 继承
```js
  // 1. 原型链继承
  // 引用类型的属性被所有实例共享, child1，child2共享继承的属性，会互相影响
  // new的时候没办法传参
  Child.prototype = new Parent()
  const child1 = new Child()
  const child2 = new Child()

  // 2. 借用构造函数
  // 优点：不会共享实例，可以传参
  // 缺点：方法在构造函数中定义，每次创建实例都会创建一次方法
  function Child () {
    Parent.call(this);
  }

  // 3. 组合继承
  // 使用构造函数继承属性，原型链继承方法，是js中最常见的继承方法
  function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
  }

  Parent.prototype.getName = function () {
    console.log(this.name)
  }

  function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
  }
```

13. css选择器  
id、类、元素、*、组合选择器：后代（空格 子孙）、子选择器（>）、相邻兄弟（+）、通用兄弟（~）  
A,B	匹配满足A（和/或）B的任意元素.  
A B	匹配任意元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）  
A > B	匹配任意元素，满足条件：B是A的直接子节点  
A + B	匹配任意元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）  
A ~ B	匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A）  
属性选择器  
存在和值（Presence and value）属性选择器  
这些属性选择器尝试匹配精确的属性值：  
[attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。  
[attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。  
[attr~=val]：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素，比如位于被空格分隔的多个类（class）中的一个类。  
伪类：以冒号作为前缀的关键字，可以让样式在特定状态下才存现的元素上，例如:hover  
伪元素：两个冒号为前缀的关键字，允许给被选择元素的特定部分修改样式，例如::first-line  
最根本的区别在于伪元素创建了新的元素，伪类没有  
ps: 每个选择器只能使用一个伪元素，但是可以添加多个伪类

14. 事件模型  
dom0：直接html上onclick = "function() {}" 违反html和js分离原则  
dom1：js中div1.onclick = function() {} 同一事件只能定义一个监听函数，后面的会覆盖前面的  
dom2：addEventListener、removeEventListener、dispatchEvent 
事件代理，由于事件会冒泡，所以可以在父节点同一代理  
stopPropagation 只会阻止事件传播，不会阻止当前节点其他监听函数执行，如果想要彻底阻止这个事件的传播，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法  
当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。    

15. 减少白屏时间  
cdn、不要使用内联js，会阻塞html解析、js文件位置、优化图片，修饰类图片使用background-image  

16. 闭包  
从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。  
从实践角度：以下函数才算是闭包：即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）  
在代码中引用了自由变量  
自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

17. Block Formatting context  
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  
只要元素满足下面任一条件即可触发 BFC 特性：  
html 元素  
浮动元素：float 除 none 以外的值  
绝对定位元素：position (absolute、fixed)  
display 为 inline-block、table-cells、flex  
overflow 除了 visible 以外的值 (hidden、auto、scroll)  
+ 同一个 BFC 下外边距会发生折叠
+ BFC 可以包含浮动的元素（清除浮动）
+ BFC 可以阻止元素被浮动元素覆盖  
[BFC](https://zhuanlan.zhihu.com/p/25321647)  



