1. setState是同步还是异步  
setState本身不是异步的，但是如果setState的时候react正处于更新状态，当前更新会被暂存，等上一次更新执行后执行，这个过程给人一种异步的假象。  

2. 什么是react高阶组件  
一个接受组件，返回一个新组件的纯函数。目的是为了在多个组件之间复用逻辑。（自定义hook）

3. 原型链  
```js
function Person(name = 'zzq') {
  this.name = name
}
const zzq = new Person()
zzq.__proto__ === Person.prototype // 指向实例原型
zzq.__proto__.constructor === Person // 实例原型的 constructor 指向原型的构造函数
zzq.__protp__.__proto__ === Object.prototype // 实例原型 继承自 Object的实例原型
```  
实例原型之间的继承链条就叫原型链  

对new理解：new 申请内存, 创建对象,当调用new时，后台会隐式执行new Object()创建对象。所以，通过new创建的字符串、数字是引用类型，而是非值类型。 

4. instanceof 原理
判断右边变量的 prototype(原型实例) 是否在左边变量的原型链上
```js
null instanceof null // TypeError: Right-hand side of 'instanceof' is not an object
typeof null === 'object'
```

5. bind、call、apply  
```js
function Sup() {
  this.name = 'sup'
  this.fn = function(arg1, arg2) {
    console.log(this.name, arg1, arg2)
  }
}

function Sub() {
  this.name = 'sub'
}

const sup = new Sup()
const sub = new Sub()

sup.fn('1', '2')

const fnBind = sup.fn.bind(sub, '1', '2')
fnBind()

sup.fn.call(sub, '1', '2')

sup.fn.apply(sub, ['1', '2'])

```  
call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。  
bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。

6. position  
static: 默认定位，文档布局流中的正常位置  
relative： 相对定位，正常文档流中，相对static的定位  
absolute： 绝对定位，不再存在于正常文档布局流中，有自己的层，相对于他的“包含元素”的定位
如果所有的父元素都是static，那就是相对于“初始块容器”（初始块容器有着和浏览器视口一样的尺寸， 
\<html>元素也被包含在这个容器中）的定位。  
fixed： 固定定位，与绝对定位的工作方式完全相同，只有一个主要区别：固定定位固定元素则是相对于浏览器视口本身

7. 重排(回流)和重绘  
flow: 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点 
paint: 将布局绘制(paint)在屏幕上，显示出整个页面。
reflow，页面布局发生改变，
repaint，重新绘制图像  
但重排一定会导致重绘。 

8. https
在http的基础上，服务器将自己的网站信息（域名等）和加密公钥交给第三方机构，第三方机构用自己的私钥加密，生成证书颁发给服务器。客户端获取证书后使用第三方机构的公钥解密，获取到服务器的公钥来加密通信。

9. react合成事件  
通过在jsx方式绑定的事件  
特点：React上注册的事件最终会绑在document节点上、React自身实现了一套冒泡机制，合成事件中调用e.stopProgration只会阻止合成事件不会阻止原生事件执行、React通过冒泡的方式从触发的组件到父组件回溯

10. 为什么有的时候两次setState只执行一次  
直接传递对象的setState会被合并成一次，使用函数传递state不会被合并

11. Redux原则
单一数据源（状态更好管理、撤销重做等操作更易实现）  
state只读，单向数据流，数据更好跟踪  
纯函数修改，没有副作用，相同的输入永远是相同的输出，更容易调试及单元测试

12. 继承
```js
  // 1. 原型链继承
  // 引用类型的属性被所有实例共享, child1，child2共享继承的属性，会互相影响
  // new的时候没办法传参
  Child.prototype = new Parent()
  const child1 = new Child()
  const child2 = new Child()

  // 2. 借用构造函数
  // 优点：不会共享实例，可以传参
  // 缺点：方法在构造函数中定义，每次创建实例都会创建一次方法
  function Child () {
    Parent.call(this);
  }

  // 3. 组合继承
  // 使用构造函数继承属性，原型链继承方法，是js中最常见的继承方法
  function Parent (name) {
    this.name = name;
    this.colors = ['red', 'blue', 'green'];
  }

  Parent.prototype.getName = function () {
    console.log(this.name)
  }

  function Child (name, age) {
    Parent.call(this, name);
    this.age = age;
  }
```

13. css选择器  
id、类、元素、*、组合选择器：后代（空格 子孙）、子选择器（>）、相邻兄弟（+）、通用兄弟（~）  
A,B	匹配满足A（和/或）B的任意元素.  
A B	匹配任意元素，满足条件：B是A的后代结点（B是A的子节点，或者A的子节点的子节点）  
A > B	匹配任意元素，满足条件：B是A的直接子节点  
A + B	匹配任意元素，满足条件：B是A的下一个兄弟节点（AB有相同的父结点，并且B紧跟在A的后面）  
A ~ B	匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB有相同的父节点，B在A之后，但不一定是紧挨着A）  
属性选择器  
存在和值（Presence and value）属性选择器  
这些属性选择器尝试匹配精确的属性值：  
[attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。  
[attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。  
[attr~=val]：该选择器仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素，比如位于被空格分隔的多个类（class）中的一个类。  
伪类：以冒号作为前缀的关键字，可以让样式在特定状态下才存现的元素上，例如:hover  
伪元素：两个冒号为前缀的关键字，允许给被选择元素的特定部分修改样式，例如::first-line  
最根本的区别在于伪元素创建了新的元素，伪类没有  
ps: 每个选择器只能使用一个伪元素，但是可以添加多个伪类

14. 事件模型  
dom0：直接html上onclick = "function() {}" 违反html和js分离原则  
dom1：js中div1.onclick = function() {} 同一事件只能定义一个监听函数，后面的会覆盖前面的  
dom2：addEventListener、removeEventListener、dispatchEvent 
事件代理，由于事件会冒泡，所以可以在父节点同一代理  
stopPropagation 只会阻止事件传播，不会阻止当前节点其他监听函数执行，如果想要彻底阻止这个事件的传播，不再触发后面所有click的监听函数，可以使用stopImmediatePropagation方法  
当Event.cancelable属性为true时，调用Event.preventDefault()就可以取消这个事件，阻止浏览器对该事件的默认行为。    

15. 减少白屏时间  
cdn、不要使用内联js，会阻塞html解析、js文件位置、优化图片，修饰类图片使用background-image  

16. 闭包  
从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。  
从实践角度：以下函数才算是闭包：即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）  
在代码中引用了自由变量  
自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。

17. Block Formatting context  
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  
只要元素满足下面任一条件即可触发 BFC 特性：  
html 元素  
浮动元素：float 除 none 以外的值  
绝对定位元素：position (absolute、fixed)  
display 为 inline-block、table-cells、flex  
overflow 除了 visible 以外的值 (hidden、auto、scroll)  
+ 同一个 BFC 下外边距会发生折叠
+ BFC 可以包含浮动的元素（清除浮动）
+ BFC 可以阻止元素被浮动元素覆盖  
[BFC](https://zhuanlan.zhihu.com/p/25321647)  

18. 浏览器缓存机制（HTTP缓存机制）  
request报文  
请求行  
请求头  
请求主体（post）  
response报文  
状态行  
响应头  
响应主体  

浏览器发送请求之前会查看本地的缓存，如果未过期(cache-control、exprise)，则直接使用。如果过期了，则向服务器协商缓存，如果服务器返回304无需更新或者200，并再次更新缓存以备下次使用。

19. 模块化  
将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起  
块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信  
模块化进程：  
```js
// 全局function模式
// 命名冲突
const myData = 'xxx'
const myFunction = () => {

}


// namespace模式
// 数据不安全
const myModule = {
  myData: 'xxx'
  myFunction: () => {

  }
}

// IIFE模式
// 匿名函数自调用
// module.js文件
(function(window, $) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
    $('body').css('background', 'red')
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar }
})(window, jQuery)
```

ES6模块语法与CommonJS模块的差异  
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。  
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。  

20. http2.0  
向下兼容1.1  
性能大幅提升  
二进制分帧（Binary Format）- http2.0的基石  
多路复用 (Multiplexing) / 连接共享  
头部压缩（Header Compression）  

21. 内存回收机制  
```js
// 引用计数垃圾收集：如果没有对象引用到它，就回收  
// “这个对象”分配给 a 变量
var a = {
  a: 1,
  b: 2,
}
// b 引用“这个对象”
var b = a; 
a = 1; // 现在，“这个对象”的原始引用 a 被 b 替换了，但是b还引用了，所以没回收
b = undefined; // 现在没有任何东西引用了该对象，回收

// 标记清除法
// 当变量进入执行环境（作用域）时标记为“进入环境”，退出时标记为“退出环境”，回收退出环境的变量
```

22. 内存泄漏的可能原因
意外的全局变量、遗忘的计时器、事件监听器、遗忘的闭包

23. [设计模式](https://refactoringguru.cn/design-patterns)
